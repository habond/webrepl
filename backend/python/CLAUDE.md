# Backend - FastAPI Python REPL v2.1

FastAPI server that executes Python code in session-based sandboxed environments with persistent namespaces and real-time streaming capabilities.

## Stack

- **Framework**: FastAPI 0.115.7
- **Runtime**: Python 3.11
- **Server**: Uvicorn
- **Container**: Python 3.11-slim base image (`webrepl-backend-python`)
- **Session Management**: Session-based persistent namespaces
- **Streaming**: Server-Sent Events (SSE) with threading-based real-time output

## API Endpoints

### `POST /execute/{sessionId}`
Execute Python code in session-specific persistent namespace.

**Request:**
```json
{
  "code": "x = 42\nprint(f'x = {x}')"
}
```

**Response:**
```json
{
  "output": "x = 42\n",
  "error": null
}
```

### `POST /execute-stream/{sessionId}`
Execute Python code with real-time streaming output using Server-Sent Events.

**Request:**
```json
{
  "code": "import time\nfor i in range(1,4):\n    print(f'Processing {i}')\n    time.sleep(1)"
}
```

**Response:** SSE stream with incremental output events
```
data: {"type": "output", "content": "Processing 1\n"}
data: {"type": "output", "content": "Processing 2\n"}
data: {"type": "output", "content": "Processing 3\n"}
data: {"type": "complete", "returnCode": 0}
```

### `POST /reset/{sessionId}`
Clear session-specific execution namespace.

**Response:**
```json
{
  "message": "Namespace reset successfully",
  "sessionId": "uuid"
}
```

### `GET /health`
Health check endpoint.

**Response:**
```json
{
  "status": "ok",
  "language": "python",
  "version": "2.0.0",
  "stateless": false,
  "timestamp": "2025-01-01T00:00:00Z"
}
```

## Session Architecture

### Persistent Namespaces
- Each session ID maintains its own isolated execution namespace
- Variables, imports, and function definitions persist between executions
- Sessions are completely isolated from each other
- Namespace persists until session is reset or container restart

### Session Isolation Example
```python
# Session A
x = 10
def greet(name):
    return f"Hello, {name}!"

# Session B (completely separate)
x = 20  # Different from Session A's x
y = 30  # Session A cannot see this variable
```

## Streaming Architecture

### Threading-Based Real-Time Execution
The Python backend implements true real-time streaming using a threading approach:

- **Execution Thread**: Python code runs in a separate thread with redirected stdout/stderr
- **Thread-Safe Output Capture**: `ThreadSafeStreamingStdout` class with proper locking for concurrent access
- **Real-Time Polling**: Main async loop polls output buffer every 100ms and streams immediately via SSE
- **Session Preservation**: Namespace is passed to thread and updated after execution completes

### Streaming Implementation Details
```python
class ThreadSafeStreamingStdout:
    """Thread-safe stdout that can stream output in real-time"""
    def __init__(self):
        self.buffer = []
        self.lock = threading.Lock()
        
    def write(self, text: str) -> int:
        if text:
            with self.lock:
                self.buffer.append(text)
        return len(text)
    
    def get_and_clear(self) -> str:
        """Get all output since last call and clear buffer"""
        with self.lock:
            if self.buffer:
                output = ''.join(self.buffer)
                self.buffer.clear()
                return output
            return ""
```

### Event Types
- **`output`**: Stdout content as it's generated by print() statements
- **`error`**: Stderr content including formatted tracebacks
- **`complete`**: Execution completion with return code (0 for success, 1 for error)

### Benefits
- **True Real-Time**: Output appears as soon as print() statements execute
- **Proper Timing**: Handles time.sleep() and long-running operations correctly
- **Session Isolation**: Each session maintains separate execution environments
- **Error Handling**: Comprehensive exception handling with proper traceback formatting

## Security

- Code execution is isolated within the container
- No file system access outside container  
- No network access from executed code
- Each session uses its own isolated namespace
- Session namespaces prevent cross-session variable access

## Development

### Local Development Setup
```bash
# Create virtual environment
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt -r requirements-dev.txt

# Run development server
make dev
# or
uvicorn main:app --host 0.0.0.0 --port 8000 --reload

```

### Code Quality
```bash
# Run all checks (lint + type-check)
make check

# Auto-format code
make format

# Lint code
make lint
# or
ruff check .
black --check .

# Type checking
make type-check  
# or
mypy .
```

## Configuration

- **CORS**: Environment-based configuration
  - Development (`ENVIRONMENT=development`): Allows all origins
  - Production: Restricted to specific frontend origins
- **Port**: 8000 (internal container port)
- **Host**: 0.0.0.0 (binds to all interfaces)
- **Session Storage**: In-memory dictionary with session ID keys

## Code Execution Flow

1. Receive POST request with Python code and session ID
2. Get or create session-specific namespace dictionary
3. Create isolated StringIO buffers for stdout/stderr
4. Execute code in session namespace using `exec(code, session_namespace)`
5. Capture output and any exceptions
6. Update session namespace with new variables/functions
7. Return structured response with output/error

## Session Management Implementation

```python
# Session namespaces stored in memory
session_namespaces = {}

def get_session_namespace(session_id: str) -> dict:
    """Get or create namespace for session."""
    if session_id not in session_namespaces:
        session_namespaces[session_id] = {"__builtins__": __builtins__}
    return session_namespaces[session_id]

def reset_session_namespace(session_id: str):
    """Reset session namespace to clean state."""
    session_namespaces[session_id] = {"__builtins__": __builtins__}
```

## Error Handling

- **Parse Errors**: Python syntax errors caught and returned in `error` field
- **Runtime Errors**: Exceptions during execution caught and returned
- **Import Errors**: Module import failures handled gracefully
- **Empty Code**: Returns HTTP 400 with appropriate error message

## Testing

The backend can be tested by accessing the health endpoint and executing sample Python code through the API.

## Development Commands

Available Makefile targets:
- `make dev` - Start development server with auto-reload
- `make check` - Run all code quality checks
- `make format` - Auto-format code with black and ruff
- `make lint` - Check code style and linting
- `make type-check` - Run mypy type checking